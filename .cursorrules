# Graph Bank System - Cursor Rules

## 專案概述
這是一個基於 Cursor 的 **Memory + Graph** 記憶銀行系統，整合 MCP Memory Server 和 Graph Bank，提供分層任務管理和自定義模式整合，用於高效的開發工作流程。

## 開發環境
- 作業系統：Windows 11
- 包管理器：yarn
- 編輯器：Cursor (版本 0.48 或更高)
- AI 模型：Claude 4 Sonnet 或 Claude 4 Opus (推薦)

## 核心架構
- **分層規則載入**：僅載入必要規則，使用專門的延遲載入
- **漸進式文件**：簡潔的模板，隨任務複雜度擴展
- **統一上下文傳輸**：模式間高效的上下文保存
- **模式特定視覺地圖**：每個開發階段的清晰視覺表示

## 自定義模式
1. **INIT** (🚀) - 系統初始化：統一系統健康檢查和環境驗證
2. **VAN** (🔍) - 專案分析：分析專案結構並確定複雜度
3. **PLAN** (📋) - 任務規劃：建立詳細的實施計劃
4. **CREATIVE** (🎨) - 設計決策：探索複雜組件的設計選項
5. **IMPLEMENT** (⚒️) - 代碼實施：系統性地構建計劃的組件
6. **REFLECT** (📝) - 審查：回顧並記錄經驗教訓
7. **ARCHIVE** (📁) - 歸檔：建立全面的文件
8. **REPO** (📚) - 倉庫分析：全面的倉庫分析和文檔生成

### 增強模式配置
- **基礎配置**：使用本文件的核心模式定義
- **詳細配置**：參考 `.cursor/rules/isolation_rules/Modes/` 目錄中的詳細指令文件
- **操作指南**：詳細步驟請參考 `AGENTS.md`

> **配置選擇**：Level 1-2 任務使用基礎配置，Level 3-4 任務建議使用詳細配置

### 詳細模式規則文件
- `init-mode-detailed.mdc` - INIT 模式詳細指令
- `van-mode-detailed.mdc` - VAN 模式詳細指令
- `plan-mode-detailed.mdc` - PLAN 模式詳細指令
- `creative-mode-detailed.mdc` - CREATIVE 模式詳細指令
- `implement-mode-detailed.mdc` - IMPLEMENT 模式詳細指令
- `reflect-archive-mode-detailed.mdc` - REFLECT+ARCHIVE 模式詳細指令
- `repo-mode-detailed.mdc` - REPO 模式詳細指令

## 工作流程
- **Level 1 任務**：INIT → VAN → IMPLEMENT → REFLECT
- **Level 2 任務**：INIT → VAN → PLAN → IMPLEMENT → REFLECT
- **Level 3-4 任務**：INIT → VAN → PLAN → CREATIVE → IMPLEMENT → REFLECT → ARCHIVE

## 核心文件
**📁 重要：所有核心 Graph Bank 文件必須位於 `graph-bank/` 目錄下**

- `graph-bank/tasks.md`：任務追蹤的中央真實來源
- `graph-bank/activeContext.md`：維護當前開發階段的焦點
- `graph-bank/progress.md`：追蹤實施狀態
- `graph-bank/projectbrief.md`：專案簡介和概述
- `graph-bank/productContext.md`：產品上下文和需求
- `graph-bank/systemPatterns.md`：系統模式和架構
- `graph-bank/techContext.md`：技術上下文和決策
- `graph-bank/creative/creative-[feature_name].md`：CREATIVE 模式期間生成的設計決策文件
- `graph-bank/reflection/reflection-[task_id].md`：REFLECT 模式期間創建的審查文件
- `graph-bank/archive/archive-[task_id].md`：任務歸檔文件

## 開發規範
- 使用繁體中文進行交流
- 遵循分層規則載入架構
- 保持代碼的模組化和可擴展性
- 優化 token 使用效率
- 確保模式間的無縫轉換

## MCP Memory Server 初始化協議
**🚨 強制執行：在執行任何 AI agent 動作之前，必須：**

1. **檢查 MCP Memory Server 狀態**
2. **載入 MCP Memory 上下文**
3. **建立對話基線**

### MCP Memory Server 指令
- **MEMORY.CHECK** - 檢查 MCP Memory Server 狀態和連接
- **MEMORY.LOAD** - 載入 MCP Memory Server 上下文和歷史數據
- **MEMORY.UPDATE** - 更新 MCP Memory Server 記憶內容
- **MEMORY.SAVE** - 儲存新信息到 MCP Memory Server
- **MEMORY.FIND** - 語義搜索記憶內容
- **MEMORY.RECALL** - 基於時間範圍回憶記憶
- **MEMORY.TAG** - 按標籤檢索記憶
- **MEMORY.DELETE** - 刪除特定記憶
- **MEMORY.HEALTH** - 檢查記憶系統健康狀態
- **MEMORY.SUMMARY** - 生成記憶摘要

> **詳細操作指南請參考 `AGENTS.md`**

## Graph Bank 文件管理協議
**📁 專案文件管理：在任務進行過程中，必須：**

1. **更新 Graph Bank 文件**
2. **同步 Graph Bank 狀態**

> **詳細操作指南請參考 `AGENTS.md`**

## Agent 檢查時機
- **INIT Agent**: 系統初始化前檢查 MCP Memory，初始化後更新 Graph Bank
- **VAN Agent**: 專案分析前檢查 MCP Memory，分析後更新 Graph Bank
- **PLAN Agent**: 任務規劃前檢查 MCP Memory，規劃後更新 Graph Bank
- **CREATIVE Agent**: 設計決策前檢查 MCP Memory，決策後更新 Graph Bank
- **IMPLEMENT Agent**: 代碼實施前檢查 MCP Memory，實施後更新 Graph Bank
- **REFLECT Agent**: 審查開始前檢查 MCP Memory，完成後更新 Graph Bank
- **ARCHIVE Agent**: 歸檔開始前檢查 MCP Memory，完成後更新 Graph Bank

> **詳細操作流程請參考 `AGENTS.md`**

## 快捷指令對照表
**⚡ 快速操作指令：在對話中輸入以下指令可快速執行對應功能**

### Context7 整合指令
- **u7** - 觸發 Context7 整合，使用 MCP Context7 服務器獲取最新文檔

### Sequential Thinking 指令
- **st7** - 觸發 Sequential Thinking，使用 MCP Sequential Thinking 服務器進行動態問題解決和反思

### Repomix 倉庫分析指令
- **rp7** - 運行壓縮模式倉庫分析（精簡版）
  ```bash
  docker run --rm -v "D:\7Spade\cursor-memory-bank:/workspace" -w /workspace ghcr.io/yamadashy/repomix:latest --output compressed-analysis.md --style markdown --include "angular/src/**" --ignore "**/*.spec.ts,**/*.test.ts,**/*.stories.ts,**/node_modules/**,**/dist/**,**/coverage/**,**/*.d.ts,**/environments/environment.*.ts"
  ```
- **rp7f** - 運行完整模式倉庫分析
  ```bash
  docker run --rm -v "D:\7Spade\cursor-memory-bank:/workspace" -w /workspace ghcr.io/yamadashy/repomix:latest --output compressed-analysis.md --style markdown --include "angular/src/**"
  ```

### 使用說明
- 在任何 Agent 模式下都可以使用這些快捷指令
- 指令會自動執行對應的 MCP 服務器功能
- 執行結果會整合到當前的 Graph Bank 系統中

## 品質保證
- 在任何模式下輸入 "QA" 可執行技術驗證
- 遵循漸進式文件方法
- 保持代碼的可讀性和可維護性
- 定期進行代碼審查和優化